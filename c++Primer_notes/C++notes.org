* Chapter 2: C++ Basics
** Variable
** Counpound Type
1. reference: reference give an object another name. reference type refers to
   another type. 
   - Reference must be initialized: During normal initialization, an initial value is
     copied into a brand new object. However, when we define a reference, the
     program binds the reference to its initial value instead of copy. The
     binding remains throughout the program so you cannot rebind the reference
     to a new value. 

   - Reference is NOT an object. Therefore, you cannot define a reference to
     another reference.

   - Within almost all contexts, a variable defined as reference is treated as a
     synonym for the object to which it refers. There are two examples:

     a. Assignment to a reference is actually assignment to the object binded to
     the reference. 
     b. When we use a reference as an initializer, the initializer is actually
     the corresponding object. 

   - Type of reference must match the type of the object to which it
     refers. However, there are two exceptioins: [[An exception][here]]  [[][here]]. 

2. Pointer: pointer is the memory address of another object.
   - Pointer itself is an object. Assignment and copy to a pointer is
     allowed. This is different from reference. 

   - Uninitialized pointer has garbage value (except it is non-automatic).

   - Since reference is NOT an object, we cannot create a pointer to a
     reference.

   - Just like reference, type of a pointer must exactly match the type of the
     object it's pointing  to, except two situation: [[][here]] and [[][here]].

   - Status of a pointer:
     a. point to an object
     b. point to the next position of an object
     c. nullptr
     d. invalid pointer: non of the above.

   - Do not assign an int variable to a pointer.

   - It is better to initialize all pointers.

   - Two pointers are equal if they contain the same memory address.

3. Declaration
   - int* p1, p2: p1 is a pointer to an int while p2 is an int.

   - reference to a pointer: int *&r
     Read the declaration from right to left.

   - base_type (declarator)(type_name)

   - A declaration can only have one base type.

** Const identifier
If we want a variable to be constant throughout the program, we can declare it
with const identifier. /A const object must be initialized./

1. Note that const identifier is part of "type". What this means is that int is
   a type different from const int. This is important when we are considering
   compound type.

2. Any operation on const object cannot change its value. However, It's OK to
   use a const object for initialization because initialization is copy.

3. By default linkage is external for non-const symbols and static (internal)for
   const symbols. This follows from C++ standard: A name of file scope that is
   explicitly declared const, and not explicitly declared extern, has internal
   linkage, while in C it would have external linkage.

4. Reference to a const object
   Note that many C++ programmer often call "reference to a const object" a
   "const reference", which is reasonable to some extent. However, we should
   always remember that this is incorrect.

   Strictly speaking, there is no such thing as "const reference". We cannot
   apply const identifier to a reference type because reference is not an
   object. In fact, since C++ does not allow modifications to the object a
   reference binds to, all reference is "constant" in a sense. Whether or not
   the object being referenced is const only determines which operations the
   reference can perform.

   - <<An exception>> : we are allowed to use expression of any type(literal is
     a kind of expression) to initialize a reference to a const object, provided
     that the type conversion is feasible. 
     
     When a "const reference" is binded to another type, like:
     #+BEGIN_SRC c++

         double dval = 3.14;
         const int &ri = dval;

     #+END_SRC
     To make sure that r1 binds to an int value, the compiler does the
     following:
     #+BEGIN_SRC c++
          const int temp = dval;
          const int &ri = temp;
     #+END_SRC
     If ri is not const reference, the assignment is illegal.

   - Const reference can bind to a non-const object. Then we cannot change the
     value of that object through this reference.

5. Pointer and const
   - pointer to const: const int *pc = &i;
     Cannot change the content of the object through a pointer to const. Also,
     to store the address of a const object, we must use pointer to
     const. Otherwise, it is possible to change the content of that object
     through this pointer. 

   - const Pointer: int *const cp = &i;
     Since pointer is an object, const identifier can apply to pointer.

6. Low-level const and top-level const
   - Top-level const is used to indicate an object is const. An object which is
     top-level const can be copied because copy will not change value of the
     original object.

   - Low-level const means the object the pointer points to is const (similiar
     logic applies to reference). For low-level const, copy operation is no
     longer an unrestricted operation (particularly this means that we cannot
     copy a low level const object to a non-low-level const object.

7. C++11: constexpr

   A constant expression is an expression whose value cannot be changed and that
   can be evaluated at compile time. A literal is a constant expression. A const
   object that is initialized from a constant expression is also a constant
   expression. 

   In the new C++ standard, we can ask the compiler to check for us whether a
   variable is a constant expression.
   #+BEGIN_EXPORT c++
   constexpr int m = 20;       // correct
   constexpr int lim = m + 1   // correct
   constexpr int sz = size();  // correct only if size() is a constant expression.
#+END_EXPORT
   - "Literal type" is used to initialize variable of type constexpr. Literal
     type could be primitive arithmetic type, pointer and reference. Struct is
     not literal type.

   - The object pointed to by a constexpr pointer (or binds to a constexpr
     reference) must be nullptr, 0 or variable allocated to fixed memory
     address. Those variables are non-automatic.

   - constexpr pointer is *top-level const*: The constexpr specifier applies to
     the pointer, not the type to which the pointer points. Therefore, constexpr
     pointer is top-level const pointer. Now the confusion occurs. One may
     recall that a top-level pointer just means we cannot change the address
     stored but does not impose any restrictions on the content in that
     address. Therefore, constexpr pointer does not mean we cannot change the
     content. It depends on the type to which the pointer points.
     #+BEGIN_SRC c++
     constexpr int *np = nullptr;
     int j=0;
     constexpr int i = 42;
     // i and j must be defined outside any function
     constexpr const int *p = &i;     // p is a constant pointer to the const int i
     constexpr int *pl = &j;          // pl is a constant pointer to the int j
#+END_SRC

** Dealing with Types
1. Type Alias
   A *type alias* is a name that is a synonym for another type. Type aliases
   symplify complicated type definitions.
      
   There are two ways of defining type alias. The second one is from new
   C++11 standard.
   - typedef
     #+BEGIN_SRC c++
       typedef double wages;
       typedef wages base, *p;    // base is a synonym for double; p for *double
	#+END_SRC
   - *alias declaration*
     #+BEGIN_SRC c++
       using SI = Sales_item;    // SI is synonym for Sales_item
	#+END_SRC
   - Pointers, const, and Type Alias
     Consider the following example:
     #+BEGIN_SRC c++
       typedef char *pstring;
       const pstring cstr = 0;
       const pstring *ps;
	#+END_SRC

     The base type in these declaration is const pstring. As usual, the const
     that appears in the base type modifies the given type. The type of pstring
     is "pointer to char." Therefore, const pstring is a "const pointer to
     char." 

2. The auto Type Specifier
   Unlike type specifier, like double, auto tells the compiler to deduce the
   type from the initializer. By implication, a variable that uses auto as its
   type specifier must have an initializer.

   As with any other type specifier, we can define multiple variables using
   auto. Because *a declaration can involve only a single base type*, the
   initializer for all the variables in the declaration list must have types
   that are consistent with each other. 

   - Compound Type, const and auto
     The type that the compiler infers for auto is not always exactly the same
     as the initializer's type.

     First, in almost all circumstances (only one exception with decltype), when we are
     using a reference, we are really using the object to which the reference
     refers. Therefore, when we use reference as initializer, the initializer is
     the corresponding object:
     #+BEGIN_SRC c++
     int i=0, &r = i;
     auto a = r;    // a is an int
#+END_SRC
     Second, auto ordinarily ignores top-level consts.
     #+BEGIN_SRC c++
     const int ci = i, &cr = ci;
     auto b = ci;    // b is an int
     auto c = cr;    // c is an int; cr is an alias for ci whose const is top-level
     auto d = &i;    // d is an int*
     auto e = &ci;   // e is an const int* (& of a const object is low-level const)
#+END_SRC
     If we want the deduced type to be const, we must explicitly add const
     specifier before auto.

     We can specify that we want a reference to the auto-deduced type.

     #+BEGIN_SRC c++
       auto &q = ci;        // for plain reference, type must match
       auto &h = 42;        // error: can't bind a plain reference to a literal
       const auto &j = 42;  // reference to const can accept initializer of any type
     #+END_SRC
       
3. TODOS: The decltype Type Specifier
   
       
* Chapter 3: Strings, Vectors and Arrays
** Namespace /using/ Declaration
1. Headers should not include using declarations. If a header has a using
   declaration, all the programs that include that header get that same using
   declaration, even if that is not intended.
** Direct and Copy Form of Initialization
#+BEGIN_SRC c++
  string s1;          // default initialization; s1 is the empty string
  string s2 = s1;     // s2 is a copy of s1
  string s3 = "hiya"; // s3 is a copy of the string literal
  string s4(10,'c')   // s4 is cccccccccc
#+END_SRC
1. Copy Initialization
   When using "=", we are asking the compiler to *copy initialize* the object by
   copying the initializer on the right-hand size into the object being created.

2. Direct Initialization
   If an initialization is not copy initialization, it is *direct
   initialization*

#+BEGIN_SRC c++
  string s5 = "hiya";     // copy initialization
  string s6("hiya");      // direct initialization
  string s7(10,'c');      // direct initialization
  string s8 = string(10,'c'); // copy
#+END_SRC
** Operations on String
1. /cin>>string/ first discards any leading white spaces. Then it reads
   characters until a white space is encountered.
2. /getline(is, s)/ reads the given stream up to and including the first newline
   and stores what it reads -- not including the newline -- in its string
   argument. It returns immediately when it encounters a newline. The newline is
   discarded. 
** Vectors
1. Vector is a template, not a type. Types generated from vector must include
   the element type.
2. Vector can hold any non-reference type because reference is not object

*** Initializing Vector
1. C++11: List initializing a vector
   We can list initialize a vector from a list of zero or more initial element
   values enclosed by curly braces:
   #+BEGIN_SRC c++
     vector<string> articles = {"a", "an", "the"};
   #+END_SRC
     
   Three restrictions so far
   * copy initialization need only one initializer
   * in-class initializer can only use copy or curly braces
   * list initialization only by curly braces

2. Value Initialization
   We can usually omit the value and supply only a size. In this case the
   library creates a *value-initialized* element initializer. The value depends
   on the object stored.
   #+BEGIN_SRC c++
     vector<int> ivec(10);     // ten elements, each initialized to 0
     vector<string> svec(10);  // ten elements, each initialized to empty string
   #+END_SRC

   * Restrictions:
     1. If some classes do not have default constructor, we cannot use this
        method. Instead, we must suppoy an instance of the object.
	#+BEGIN_SRC c++
          vector<int> ivec(10, 1);
	#+END_SRC
     2. If we only supply the element count, we must use this method.

3. List Initializer or Element Count?
   * Rule 1
     When we use parentheses, we are saying that the values we supply are to be
     used to construct the object.

   * Rule 2
     When we use curly braces, we are saying that, if possible, we want to /list
     initialize/ the object. Only if it is not possible to list initialize the
     object will the other ways to initialize the object be considered.

     #+BEGIN_SRC c++
       vector<string> v5{"hi"};     // list initialization: v5 has one element
       vector<string> v6("hi");     // error: cannot construct a vector of string from string literal
       vector<stirng> v7{10};       // There is no way to list initialize, so v7 has ten empty strings
       vector<string> v8{10, "hi"}; // v8 has ten elements initialized to "hi"
     #+END_SRC

     Note that only v5 is successfully list initialized.

*** Grow Efficiency
    Unless we need a vector that all elements are the same, it is better to
    define an empty vector and grow it gradually.
*** Range For
   * The body of /range for/ must not change the size of the sequence which it
     is iterating 
   * range for is a way to avoid indexing non-existent element in a sequence.
    

** Iterator
Iterator is a more general mechanisim to access elements in a container. Just
like pointers, it provides indirect acess to object which could be an element in
a container or a character in a string. All library containers have iterator
although some of them does not  subscripting operation.

*** Validity
    A valid iterator either denotes an elements or denotes a position one past
    the last element in a container. *All other iterators are invalid.*

*** Using Iterator
We can only obtain an iterator object by calling member functions that return
iterator type. Moreover, we do not care about the precise type an iterator
has. We can just use /auto/ to define an iterator object returned by some member
functions of the containers.
#+BEGIN_SRC c++
  // the compiler determines the type of a and b
  // a denotes the first element (if the container has one) and
  // e denotes one past the last element in v
  auto a = v.begin(), b = v.end() // a and b have the same type
#+END_SRC

*Note:* If a container is empty, the iterators returned by /begin/ and /end/ are
        equal -- they are both the off-tne-end iterators.

*** Iterator Operations
    *iter               Return a reference to the element denoted by the
                        iterator iter.
    iter->mem           Dereferences /iter/ and fetches the member named /mem/
                        from the underlying element. Equivalent to (*iter).mem 
    ++iter              Increment the /iter/ to refer to the next element in the
                        container. 
    --iter              Decrement the /iter/ to refer to the previous element in
                        the container.
    iter1 == iter2      Compares two iterators for equality (inequality). Two
    iter1 != iter2      iterators are equal if they denotes the same element or
                        if they are the off-the-end iterator for the same
                        container.

*Note:* Since iterator returned by /end()/ does not denote an element, it may
        not be incremented or decremented.

*Note:* /const_iterator/ type is a low-level const object. It is recommanded
        that we use const iterator when we only need to read elements from a
        container. The C++11 introduces /cbegin/ and /cend/ that always return
        constant iterator regardless of whether the container is const or
        non-const. 

*** Some vector Operations Invalidate Iterator
    Since vector can grow dynamically, we noted that we cannot modify the vector
    in a ranged for loop. Another implication is that operations, such as
    /push_back/ , that changes the size of a vector potentially invalidates all
    iterators into that vector.

*Warning:* A loop should not add elements to the container to which the
           iterators refer.

*** Iterator Arithmetic (for /vector/ and /string/)
    iter + n            Adding (subtracting) an integral value n to (from) an
    iter - n            iterator that many elements forward (backward) within
                        the container. *The resulting iterator must be still*
			*valid in the same container.*
    iter1 += n          
    iter1 -= n
    iter 1 - iter 2     Subtracting two iterators yields the number that when
                        added to the right-hand iterator yields the left-hand
			iterator. The iterators must be valid in the same
			container. 
    >, >=, <, <=        Relational operators on iterators. One iterator is less
                        than another if it refers to an element that appears in
			the container before the one referred toby the other
			iterator. The iterators must be valid in the same
			container.

    Example: Binary Search
    #+BEGIN_SRC c++
      // text must be sorted
      // beg and end denote the range we are searching
      auto beg = text.cbegin();
      auto end = text.cend();
      auto mid = text.cbegin() + (end - beg)/2;

      while(mid != end && *mid != sought) {
        if(sought < *mid)     // is the element we want in the first half
          end = mid;          // if so, adjust the range to ignore the second half
        else                  // the lement we want is in the second half
          beg = mid + 1;      // start looking with the element just after mid 
        mid = beg + (end - beg)/2; // new midpoint
       }
    #+END_SRC

** Arrays
