* Chapter 2: C++ Basics
** Counpound Type
1. reference: reference give an object another name. reference type refers to
   another type. 
   - Reference must be initialized: During normal initialization, an initial value is
     copied into a brand new object. However, when we define a reference, the
     program binds the reference to its initial value instead of copy. The
     binding remains throughout the program so you cannot rebind the reference
     to a new value. 

   - Reference is NOT an object. Therefore, you cannot define a reference to
     another reference.

   - Within almost all contexts, a variable defined as reference is treated as a
     synonym for the object to which it refers. There are two examples:

     a. Assignment to a reference is actually assignment to the object binded to
     the reference. 
     b. When we use a reference as an initializer, the initializer is actually
     the corresponding object. 

   - Type of reference must match the type of the object to which it
     refers. However, there are two exceptioins: [[An exception][here]]  [[][here]]. 

2. Pointer: pointer is the memory address of another object.
   - Pointer itself is an object. Assignment and copy to a pointer is
     allowed. This is different from reference. 

   - Uninitialized pointer has garbage value (except it is non-automatic).

   - Since reference is NOT an object, we cannot create a pointer to a
     reference.

   - Just like reference, type of a pointer must exactly match the type of the
     object it's pointing  to, except two situation: [[][here]] and [[][here]].

   - Status of a pointer:
     a. point to an object
     b. point to the next position of an object
     c. nullptr
     d. invalid pointer: non of the above.

   - Do not assign an int variable to a pointer.

   - It is better to initialize all pointers.

   - Two pointers are equal if they contain the same memory address.

3. Declaration
   - int* p1, p2: p1 is a pointer to an int while p2 is an int.

   - reference to a pointer: int *&r
     Read the declaration from right to left.

   - base_type (declarator)(type_name)

   - A declaration can only have one base type.

** Const identifier
If we want a variable to be constant throughout the program, we can declare it
with const identifier. /A const object must be initialized./

1. Note that const identifier is part of "type". What this means is that int is
   a type different from const int. This is important when we are considering
   compound type.

2. Any operation on const object cannot change its value. However, It's OK to
   use a const object for initialization because initialization is copy.

3. By default linkage is external for non-const symbols and static (internal)for
   const symbols. This follows from C++ standard: A name of file scope that is
   explicitly declared const, and not explicitly declared extern, has internal
   linkage, while in C it would have external linkage.

4. Reference to a const object
   Note that many C++ programmer often call "reference to a const object" a
   "const reference", which is reasonable to some extent. However, we should
   always remember that this is incorrect.

   Strictly speaking, there is no such thing as "const reference". We cannot
   apply const identifier to a reference type because reference is not an
   object. In fact, since C++ does not allow modifications to the object a
   reference binds to, all reference is "constant" in a sense. Whether or not
   the object being referenced is const only determines which operations the
   reference can perform.

   - <<An exception>> : we are allowed to use expression of any type(literal is
     a kind of expression) to initialize a reference to a const object, provided
     that the type conversion is feasible. 
     
     When a "const reference" is binded to another type, like:
     #+BEGIN_SRC c++

         double dval = 3.14;
         const int &ri = dval;

     #+END_SRC
     To make sure that r1 binds to an int value, the compiler does the
     following:
     #+BEGIN_SRC c++
          const int temp = dval;
          const int &ri = temp;
     #+END_SRC
     If ri is not const reference, the assignment is illegal.

   - Const reference can bind to a non-const object. Then we cannot change the
     value of that object through this reference.

5. Pointer and const
   - pointer to const: const int *pc = &i;
     Cannot change the content of the object through a pointer to const. Also,
     to store the address of a const object, we must use pointer to
     const. Otherwise, it is possible to change the content of that object
     through this pointer. 

   - const Pointer: int *const cp = &i;
     Since pointer is an object, const identifier can apply to pointer.

6. Low-level const and top-level const
   - Top-level const is used to indicate an object is const. An object which is
     top-level const can be copied because copy will not change value of the
     original object.

   - Low-level const means the object the pointer points to is const (similiar
     logic applies to reference). For low-level const, copy operation is no
     longer an unrestricted operation (particularly this means that we cannot
     copy a low level const object to a non-low-level const object.

7. C++11: constexpr

   A constant expression is an expression whose value cannot be changed and that
   can be evaluated at compile time. A literal is a constant expression. A const
   object that is initialized from a constant expression is also a constant
   expression. 

   In the new C++ standard, we can ask the compiler to check for us whether a
   variable is a constant expression.
   #+BEGIN_EXPORT c++
   constexpr int m = 20;       // correct
   constexpr int lim = m + 1   // correct
   constexpr int sz = size();  // correct only if size() is a constant expression.
#+END_EXPORT
   - "Literal type" is used to initialize variable of type constexpr. Literal
     type could be primitive arithmetic type, pointer and reference. Struct is
     not literal type.

   - The object pointed to by a constexpr pointer (or binds to a constexpr
     reference) must be nullptr, 0 or variable allocated to fixed memory
     address. Those variables are non-automatic.

   - constexpr pointer is *top-level const*: The constexpr specifier applies to
     the pointer, not the type to which the pointer points. Therefore, constexpr
     pointer is top-level const pointer. Now the confusion occurs. One may
     recall that a top-level pointer just means we cannot change the address
     stored but does not impose any restrictions on the content in that
     address. Therefore, constexpr pointer does not mean we cannot change the
     content. It depends on the type to which the pointer points.
     #+BEGIN_SRC c++
     constexpr int *np = nullptr;
     int j=0;
     constexpr int i = 42;
     // i and j must be defined outside any function
     constexpr const int *p = &i;     // p is a constant pointer to the const int i
     constexpr int *pl = &j;          // pl is a constant pointer to the int j
#+END_SRC

** Dealing with Types
1. Type Alias
   A *type alias* is a name that is a synonym for another type. Type aliases
   symplify complicated type definitions.
      
   There are two ways of defining type alias. The second one is from new
   C++11 standard.
   - typedef
     #+BEGIN_SRC c++
       typedef double wages;
       typedef wages base, *p;    // base is a synonym for double; p for *double
	#+END_SRC
   - *alias declaration*
     #+BEGIN_SRC c++
       using SI = Sales_item;    // SI is synonym for Sales_item
	#+END_SRC
   - Pointers, const, and Type Alias
     Consider the following example:
     #+BEGIN_SRC c++
       typedef char *pstring;
       const pstring cstr = 0;
       const pstring *ps;
	#+END_SRC

     The base type in these declaration is const pstring. As usual, the const
     that appears in the base type modifies the given type. The type of pstring
     is "pointer to char." Therefore, const pstring is a "const pointer to
     char." 

2. The auto Type Specifier
   Unlike type specifier, like double, auto tells the compiler to deduce the
   type from the initializer. By implication, a variable that uses auto as its
   type specifier must have an initializer.

   As with any other type specifier, we can define multiple variables using
   auto. Because *a declaration can involve only a single base type*, the
   initializer for all the variables in the declaration list must have types
   that are consistent with each other. 

   - Compound Type, const and auto
     The type that the compiler infers for auto is not always exactly the same
     as the initializer's type.

     First, in almost all circumstances (only one exception with decltype), when we are
     using a reference, we are really using the object to which the reference
     refers. Therefore, when we use reference as initializer, the initializer is
     the corresponding object:
     #+BEGIN_SRC c++
     int i=0, &r = i;
     auto a = r;    // a is an int
#+END_SRC
     Second, auto ordinarily ignores top-level consts.
     #+BEGIN_SRC c++
     const int ci = i, &cr = ci;
     auto b = ci;    // b is an int
     auto c = cr;    // c is an int; cr is an alias for ci whose const is top-level
     auto d = &i;    // d is an int*
     auto e = &ci;   // e is an const int* (& of a const object is low-level const)
#+END_SRC
     If we want the deduced type to be const, we must explicitly add const
     specifier before auto.

     We can specify that we want a reference to the auto-deduced type.

     #+BEGIN_SRC c++
       auto &q = ci;        // for plain reference, type must match
       auto &h = 42;        // error: can't bind a plain reference to a literal
       const auto &j = 42;  // reference to const can accept initializer of any type
     #+END_SRC
       
3. The decltype Type Specifier
   
       
* Chapter 3: Strings, Vectors and Arrays
