* Chapter 2: C++ Basics
** Variable
*** Type Conversion
*** Scope
** Counpound Type
1. reference: reference give an object another name. reference type refers to
   another type. 
   - Reference must be initialized: During normal initialization, an initial value is
     copied into a brand new object. However, when we define a reference, the
     program binds the reference to its initial value instead of copy. The
     binding remains throughout the program so you cannot rebind the reference
     to a new value. 

   - Reference is NOT an object. Therefore, you cannot define a reference to
     another reference.

   - Within almost all contexts, a variable defined as reference is treated as a
     synonym for the object to which it refers. There are two examples:

     a. Assignment to a reference is actually assignment to the object binded to
     the reference. 
     b. When we use a reference as an initializer, the initializer is actually
     the corresponding object. 

   - Type of reference must match the type of the object to which it
     refers. However, there are two exceptioins: [[An exception][here]]  [[][here]]. 

2. Pointer: pointer is the memory address of another object.
   - Pointer itself is an object. Assignment and copy to a pointer is
     allowed. This is different from reference. 

   - Uninitialized pointer has garbage value (except it is non-automatic).

   - Since reference is NOT an object, we cannot create a pointer to a
     reference.

   - Just like reference, type of a pointer must exactly match the type of the
     object it's pointing to, except two situation: [[][here]] and [[][here]].

   - Status of a pointer:
     a. point to an object
     b. point to the next position of an object
     c. nullptr
     d. invalid pointer: non of the above.

   - Do not assign an int variable to a pointer.

   - It is better to initialize all pointers.

   - Two pointers are equal if they contain the same memory address.

3. Declaration
   - int* p1, p2: p1 is a pointer to an int while p2 is an int.

   - reference to a pointer: int *&r
     Read the declaration from right to left.

   - base_type (declarator)(type_name)

   - A declaration can only have one base type.

** Const identifier
If we want a variable to be constant throughout the program, we can declare it
with const identifier. /A const object must be initialized./

1. Note that const identifier is part of "type". What this means is that int is
   a type different from const int. This is important when we are considering
   compound type.

2. Any operation on const object cannot change its value. However, It's OK to
   use a const object for initialization because initialization is copy.

3. By default linkage is external for non-const symbols and static (internal)for
   const symbols. This follows from C++ standard: A name of file scope that is
   explicitly declared const, and not explicitly declared extern, has internal
   linkage, while in C it would have external linkage.

4. Reference to a const object
   Note that many C++ programmer often call "reference to a const object" a
   "const reference", which is reasonable to some extent. However, we should
   always remember that this is incorrect.

   Strictly speaking, there is no such thing as "const reference". We cannot
   apply const identifier to a reference type because reference is not an
   object. In fact, since C++ does not allow modifications to the object a
   reference binds to, all reference is "constant" in a sense. Whether or not
   the object being referenced is const only determines which operations the
   reference can perform.

   - <<An exception>> : we are allowed to use expression of any type(literal is
     a kind of expression) to initialize a reference to a const object, provided
     that the type conversion is feasible. 
     
     When a "const reference" is binded to another type, like:
     #+BEGIN_SRC c++

         double dval = 3.14;
         const int &ri = dval;

     #+END_SRC
     To make sure that r1 binds to an int value, the compiler does the
     following:
     #+BEGIN_SRC c++
          const int temp = dval;
          const int &ri = temp;
     #+END_SRC
     If ri is not const reference, the assignment is illegal.

   - Const reference can bind to a non-const object. Then we cannot change the
     value of that object through this reference.

5. Pointer and const
   - pointer to const: const int *pc = &i;
     Cannot change the content of the object through a pointer to const. Also,
     to store the address of a const object, we must use pointer to
     const. Otherwise, it is possible to change the content of that object
     through this pointer. 

   - const Pointer: int *const cp = &i;
     Since pointer is an object, const identifier can apply to pointer.

6. Low-level const and top-level const
   - Top-level const is used to indicate an object is const. An object which is
     top-level const can be copied because copy will not change value of the
     original object.

   - Low-level const means the object the pointer points to is const (similiar
     logic applies to reference). For low-level const, copy operation is no
     longer an unrestricted operation (particularly this means that we cannot
     copy a low level const object to a non-low-level const object.

7. C++11: constexpr

   A constant expression is an expression whose value cannot be changed and that
   can be evaluated at compile time. A literal is a constant expression. A const
   object that is initialized from a constant expression is also a constant
   expression. 

   In the new C++ standard, we can ask the compiler to check for us whether a
   variable is a constant expression.
   #+BEGIN_EXPORT c++
   constexpr int m = 20;       // correct
   constexpr int lim = m + 1   // correct
   constexpr int sz = size();  // correct only if size() is a constant expression.
#+END_EXPORT
   - "Literal type" is used to initialize variable of type constexpr. Literal
     type could be primitive arithmetic type, pointer and reference. Struct is
     not literal type.

   - The object pointed to by a constexpr pointer (or binds to a constexpr
     reference) must be *nullptr, 0 or variable allocated to fixed memory*
     address. Those variables are non-automatic.

   - constexpr pointer is *top-level const*: The constexpr specifier applies to
     the pointer, not the type to which the pointer points. Therefore, constexpr
     pointer is top-level const pointer. Now the confusion occurs. One may
     recall that a top-level pointer just means we cannot change the address
     stored but does not impose any restrictions on the content in that
     address. Therefore, constexpr pointer does not mean we cannot change the
     content. It depends on the type to which the pointer points.
     
     *Additional notes on 03/10/2017:* It is easier that if we do not think
     constexpr as part of the type. Instead we can treat it as some kind of
     "modifier" that modifies the whole expression. The value of this expression
     could not be changed.


     #+BEGIN_SRC c++
     constexpr int *np = nullptr;
     int j=0;
     constexpr int i = 42;
     // i and j must be defined outside any function
     constexpr const int *p = &i;     // p is a constant pointer to the const int i
     constexpr int *pl = &j;          // pl is a constant pointer to the int j
#+END_SRC

** Dealing with Types
1. Type Alias
   A *type alias* is a name that is a synonym for another type. Type aliases
   symplify complicated type definitions.
      
   There are two ways of defining type alias. The second one is from new
   C++11 standard.
   - typedef
     #+BEGIN_SRC c++
       typedef double wages;
       typedef wages base, *p;    // base is a synonym for double; p for *double
	#+END_SRC
   - *alias declaration*
     #+BEGIN_SRC c++
     using SI = Sales_item;    // SI is synonym for Sales_item
	#+END_SRC
   - Pointers, const, and Type Alias
     Consider the following example:
     #+BEGIN_SRC c++
       typedef char *pstring;
       const pstring cstr = 0;
       const pstring *ps;
	#+END_SRC

     The base type in these declaration is const pstring. As usual, the const
     that appears in the base type modifies the given type. The type of pstring
     is "pointer to char." Therefore, const pstring is a "const pointer to
     char." 

2. The auto Type Specifier
   Unlike type specifier, like double, auto tells the compiler to *deduce the*
   *type from the initializer*. By implication, a variable that uses auto as its
   type specifier must have an initializer.

   *NOTE*: The auto type specifier can only deduces the type from its
   initializer. It is not able to reason out the type from the context.

   As with any other type specifier, we can define multiple variables using
   auto. Because *a declaration can involve only a single base type*, the
   initializer for all the variables in the declaration list must have types
   that are consistent with each other. 

   - Compound Type, const and auto
     The type that the compiler infers for auto is not always exactly the same
     as the initializer's type. 这体现在（1）用reference type来初始化auto对象得
     到的并不是reference type 和（2）auto不会是top-level const，除非在auto前面加
     上const。

     First, in almost all circumstances (only one exception with decltype), when we are
     using a reference, we are really using the object to which the reference
     refers. Therefore, when we use reference as initializer, the initializer is
     the corresponding object:
     #+BEGIN_SRC c++
     int i=0, &r = i;
     auto a = r;    // a is an int
#+END_SRC
     Second, auto ordinarily ignores top-level consts.
     #+BEGIN_SRC c++
     const int ci = i, &cr = ci;
     auto b = ci;    // b is an int
     auto c = cr;    // c is an int; cr is an alias for ci whose const is top-level
     auto d = &i;    // d is an int*
     auto e = &ci;   // e is an const int* (& of a const object is low-level const)
#+END_SRC
     If we want the deduced type to be const, we must explicitly add const
     specifier before auto.

     auto也是作为type specifier存在的，如果auto不无视top-level const的话会很容易出现程序员写出两个const的错误。
     总之，要记住没有const修饰的auto类型不可能是一个const object，也就是说，如果没有const的修饰，那么一个auto类型
     的对象永远是可以被修改的。但是它可能是low-level const。

     We can specify that we want a reference to the auto-deduced type.
     Note that we cannot bind a plain reference to a literal. See reason [[http://stackoverflow.com/questions/1565600/how-come-a-non-const-reference-cannot-bind-to-a-temporary-object][here]].

     #+BEGIN_SRC c++
       auto &q = ci;        // for plain reference, type must match
       auto &h = 42;        // error: can't bind a plain reference to a literal
       const auto &j = 42;  // reference to const can accept initializer of any type
     #+END_SRC
       
3. TODOS: The decltype Type Specifier
   
   
* Chapter 3: Strings, Vectors and Arrays
** Namespace /using/ Declaration
1. Headers should not include using declarations. If a header has a using
   declaration, all the programs that include that header get that same using
   declaration, even if that is not intended.
** Direct and Copy Form of Initialization
#+BEGIN_SRC c++
  string s1;          // default initialization; s1 is the empty string
  string s2 = s1;     // s2 is a copy of s1
  string s3 = "hiya"; // s3 is a copy of the string literal
  string s4(10,'c')   // s4 is cccccccccc
#+END_SRC
1. Copy Initialization
   When using "=", we are asking the compiler to *copy initialize* the object by
   copying the initializer on the right-hand size into the object being created.

2. Direct Initialization
   If an initialization is not copy initialization, it is *direct
   initialization*

#+BEGIN_SRC c++
  string s5 = "hiya";     // copy initialization
  string s6("hiya");      // direct initialization
  string s7(10,'c');      // direct initialization
  string s8 = string(10,'c'); // copy
#+END_SRC
** Operations on String
1. /cin>>string/ first discards any leading white spaces. Then it reads
   characters until a white space is encountered.
2. /getline(is, s)/ reads the given stream up to and including the first newline
   and stores what it reads -- not including the newline -- in its string
   argument. It returns immediately when it encounters a newline. The newline is
   discarded.
3. String Indexing []
   The index we supply can be any expression that yields an integral
   value. However, if our index has a signed type, its value will be convereted
   to the unsigned type that string::size_type represents.
** Vectors
*** About Vectors
1. Vector is a template, not a type. Types generated from vector must include
   the element type.
2. Vector can hold any non-reference type because reference is not object

*** Initializing Vector
1. C++11: List initializing a vector
   We can list initialize a vector from a list of zero or more initial element
   values enclosed by curly braces:
   #+BEGIN_SRC c++
     vector<string> articles = {"a", "an", "the"};
   #+END_SRC
     
   Three restrictions so far
   * copy initialization need only one initializer
   * in-class initializer can only use copy or curly braces
   * list initialization only by curly braces

2. Value Initialization
   We can usually omit the value and supply only a size. In this case the
   library creates a *value-initialized* element initializer. The value depends
   on the object stored. If the vector holds elements of built-in type such as
   int, then the element initializer has a value of 0.
   #+BEGIN_SRC c++
     vector<int> ivec(10);     // ten elements, each initialized to 0
     vector<string> svec(10);  // ten elements, each initialized to empty string
   #+END_SRC

   * Restrictions:
     1. If some classes do not have default constructor, we cannot use this
        method. Instead, we must supply an instance of the object.
	#+BEGIN_SRC c++
          vector<int> ivec(10, 1);
	#+END_SRC
     2. If we only supply the element count, we must use this method.

3. List Initializer or Element Count?
   * Rule 1
     When we use parentheses, we are saying that the values we supply are to be
     used to construct the object.

   * Rule 2
     When we use curly braces, we are saying that, if possible, we want to /list
     initialize/ the object. Only if it is not possible to list initialize the
     object will the other ways to initialize the object be considered.

     #+BEGIN_SRC c++
       vector<string> v5{"hi"};     // list initialization: v5 has one element
       vector<string> v6("hi");     // error: cannot construct a vector of string from string literal
       vector<stirng> v7{10};       // There is no way to list initialize, so v7 has ten empty strings
       vector<string> v8{10, "hi"}; // v8 has ten elements initialized to "hi"
     #+END_SRC

     Note that only v5 is successfully list initialized.

4. Array(iterator) initialization

*** Adding Elements to vector
    Directly initializing the elements of a vector is feasible only if we have a
    small number of known initial values, if we want to make a copy of another
    vector, of if we want to initialize all the elements to the same value.

    More commonly, we gradually add elements to the vector at run time by the
    *push_back* method. The *push_back* operation takes a value and "pushes"
    that value as a new last element on to the "back" of the vector.

    For example
    #+BEGIN_SRC c++
      vector<int> v2;              // empty vector
      for (int i=0; i != 100; ++i) 
        v2.push_back(i);           // append sequential integers to v2
      // at end of loop v2 has 100 elements, values 0 to 99.
    #+END_SRC
    Note that even though we know we ultimately will have 100 elements, we
    define v2 to be empty.

*** Grow Efficiency
    Unless we need a vector that all elements are the same, it is better to
    define an empty vector and grow it gradually.
*** Range For
   * The body of /range for/ must not change the size of the sequence which it
     is iterating 
   * range for is a way to avoid indexing non-existent element in a sequence.
    
*** Other vector Operations
    v.empty()
    v.size()          Returns the size of vector v in type vector::size_type
    v.push_back()
    v[n]              Returns a *reference* to the element at position n in v.
    
*** vector Indexing Example
    #+BEGIN_SRC c++
      vector<unsigned> scores(11,0);   // 11 buckets, all initially 0s
      unsigned grade;
      while(cin>>grade) {              // read the grade
        if(grade <= 100)               // handle only valid grades
          ++score[grade/10];           // Increment the counter for the current buckets
       }
    #+END_SRC

*** Scripting Does Not Add Elements    
    

** Iterator
Iterator is a more general mechanisim to access elements in a container. Just
like pointers, it provides indirect acess to object which could be an element in
a container or a character in a string. All library containers have iterator
although some of them does not  subscripting operation.

*** Validity
    A valid iterator either denotes an elements or denotes a position one past
    the last element in a container. *All other iterators are invalid.*

*** Using Iterator
We can only obtain an iterator object by calling member functions that return
iterator type. Moreover, we do not care about the precise type an iterator
has. We can just use /auto/ to define an iterator object returned by some member
functions of the containers.
#+BEGIN_SRC c++
  // the compiler determines the type of a and b
  // a denotes the first element (if the container has one) and
  // e denotes one past the last element in v
  auto a = v.begin(), b = v.end() // a and b have the same type
#+END_SRC

*Note:* If a container is empty, the iterators returned by /begin/ and /end/ are
        equal -- they are both the off-tne-end iterators.

*** Iterator Operations
    *iter               Return a *reference* to the element denoted by the
                        iterator iter.
    iter->mem           Dereferences /iter/ and fetches the member named /mem/
                        from the underlying element. Equivalent to (*iter).mem 
    ++iter              Increment the /iter/ to refer to the next element in the
                        container. 
    --iter              Decrement the /iter/ to refer to the previous element in
                        the container.
    iter1 == iter2      Compares two iterators for equality (inequality). Two
    iter1 != iter2      iterators are equal if they denotes the same element or
                        if they are the off-the-end iterator for the same
                        container.

*Note:* Since iterator returned by /end()/ does not denote an element, it may
        not be incremented or decremented.

*Note:* /const_iterator/ type is a *low-level const object*. It is recommanded
        that we use const iterator when we only need to read elements from a
        container. The C++11 introduces /cbegin/ and /cend/ that always return
        constant iterator regardless of whether the container is const or
        non-const. 

*** Some vector Operations Invalidate Iterator
    Since vector can grow dynamically, we noted that we cannot modify the vector
    in a ranged for loop. Another implication is that operations, such as
    /push_back/ , that changes the size of a vector potentially invalidates all
    iterators into that vector.

*Warning:* A loop should not add elements to the container to which the
           iterators refer.

*** Iterator Arithmetic (for /vector/ and /string/)
    iter + n            Adding (subtracting) an integral value n to (from) an
    iter - n            iterator that many elements forward (backward) within
                        the container. *The resulting iterator must be still*
			*valid in the same container.*
    iter1 += n          
    iter1 -= n
    iter 1 - iter 2     Subtracting two iterators yields the number that when
                        added to the right-hand iterator yields the left-hand
			iterator. The iterators must be valid in the same
			container. 
    >, >=, <, <=        Relational operators on iterators. One iterator is less
                        than another if it refers to an element that appears in
			the container before the one referred toby the other
			iterator. The iterators must be valid in the same
			container.

    Example: Binary Search
    #+BEGIN_SRC c++
      // text must be sorted
      // beg and end denote the range we are searching
      auto beg = text.cbegin();
      auto end = text.cend();
      auto mid = text.cbegin() + (end - beg)/2;

      while(mid != end && *mid != sought) {
        if(sought < *mid)     // is the element we want in the first half
          end = mid;          // if so, adjust the range to ignore the second half
        else                  // the element we want is in the second half
          beg = mid + 1;      // start looking with the element just after mid 
        mid = beg + (end - beg)/2; // new midpoint
       }
    #+END_SRC

** Arrays
*** About Arrays
Arrays are a compound type. An array declarator has the form /a[d]/.
1. The dimension must be greater than zero.
2. The number of the array is part of the type.Therefore, the dimension must be
   known at compile time which means the dimension must be a constant
   expression.

   #+BEGIN_SRC c++
     unsigned cnt = 42; // not a constant expression
     constexpr unsigned sz = 42; // a constant expression.

     int arr[10];
     int *parr[sz];
     string bad[cnt]; // error: cnt is not a constant expression.
     string strs[get_size()]; // ok if get_size() is a constant expression.
   #+END_SRC
3. By default, the elements in an array are default initialized. Therefore, *a*
   *default-initialized array of built-in type that is defined inside a function*
   *will have undefined values.*
4. We cannot use /auto/ to deduce the type of an array. The type must be
   explicitly initialized.
5. Array can only hold object.

*** Array Initialization
1. List initialization
2. Omit dimension allowed, size is deduced from initializer.
3. Size of initializer can be less than dimension. In that case, the rest of the
   elements are value-initialized.
   *Question*: difference between int arr[10] and int arr[10] = {}?
   int arr[10] is an undefined initialized array while int arr[10] = {} is an
   value-initialized array.
   *Question*: What is value-initialized?
               If the object is int, then it is initialized to be 0.

4. String literals can be used directly to initialize character array. The size
   of the resulting array is one more larger than the size of the initializer.
5. There is no copy or assignment operator for array type.
   没有copy assignment。尤其注意当要初始化一个array of array的时候。不能用既在的array。

   #+BEGIN_SRC c++
     int a[] = {0, 1, 2}; // array of three ints
     int a2[] = a; // error: cannot initialize one array with another.
     a2 = a; // error: cannot assign one array to another.
   #+END_SRC
   However, we can create a reference that binds to an existing array.
   #+BEGIN_SRC c++
     int arr[5] = {1,2,3,4,5};
     int (&arr_r)[5] = arr;
   #+END_SRC

   When creating a reference that binds to an existing array, remember that the type of reference must be exactly
   identical to the type it binds to.

   #+BEGIN_SRC C++
   int arr[] = {1, 2}; // arr has type int [2]
   int (&arr_r)[] = arr; // ERROR! Type must be exactly identical.
   
   int (&arr_r)[2] = arr; // Correct.
   #+END_SRC

   Here is a subtle example.

   #+BEGIN_SRC C++
   typedef double *arr[]; // Array to pointer of double with indefinite size.
   typedef double *arr2[2]; // Array to pointer of double with 5 elememnt.

   double d1 = 0.1, d2 = 0.2;

   arr arr_d = {&d1, &d2};
   arr2 arr_d2 = {&d1, &d2};

   arr2 &arr_r = arr_d; // Correct.
   arr &arr_r2 = arr_d; // Error!. arr_r2 does not specify the size.
   #+END_SRC
*** Pointers and Arrays
1. In most places when we use an array, the compiler automatically substitutes a
   pointer to the first element.
   #+BEGIN_SRC C++
   string nums[] = {"one", "two", "three"};
   string *p = &nums[0];
   string *p2 = nums; // equivalent to string *p2 = &nums[0];
   #+END_SRC

2. Exceptions on Pointer-Array Conversion
   One exception is when we use decltype.
   Another exception is when we use the sizeof operator.
   The third exception is when we initialize a reference type. Since the type of
   non-const reference must be identical to the initializer.

   *Note*: Despite that, pointer and array are still different types. One
   example is that the ranged for loop can only loop through array type. It is
   an error for a ranged for loop to loop through a pointer.
   
3. The New C++11 BEGIN and END funciton in header "iterator".
   Take array as an argument and return pointer to the beginning and off-the-end
   element. 

4. The ptrdiff_t type for the result type of subtracting two pointers.

5. Dereferencing and Pointer Arithmetic
   
6. Negative subscripting

*** C-style Character Strings
1. The cstring library provides functions for c-style character strings.
   strlen(p): Return the length of p, not counting the null.
   strcmp(p1, p2): Compares p1 and p2 for equality.
   strcat(p1, p2): Append p2 to p1. Returns p1.
   strcpy(p1, p2): Copies p2 into p1. Returns p1.

2. Those functions do not verify their string parameters.

3. It is caller's responsibility to check the size of a destination string. In
   function strcpy. p1 must be large enough to hold p2.

*** Interface to Older Code
1. We can use c-style character array anywhere that we can use string
   literals. 

2. We can use the memeber funciton of string c_str() to obtain a c-style
   character array.
   - The type of the pointer is const char*
   - It is not guaranteed that the array will remain valid indefinitely. Any
     subsequent change of the original string may invalidate that array.

* Chapter 4: Expressions

  An Expression is composed of one or more *operands* and yields a *result* when
  it is evaluated.

** Lvalue and Rvalue
   A famous definition for lvalue and rvalue is that lvalue appears at the left
   side of assignment but rvalue appears at the right side. In C++, however, it
   is a little bit more complicated.

   An expression is either an lvalue or a rvalue. Lvalue can replace rvalue but
   rvalue cannot replace lvalue.

   - Lvalue represents object that occupies some identifiable memory location
   - Rvalue represents everything that is not lvalue...

   Some facts about lvalue and rvalue:
   - Assignment requires nonconst lvalue at its left side and it yields it left
     side as an lvalue.
   - The address-of operator (&) requires its operand as lvalue and returns a
     pointer as rvalue.
   - The built-in dereference and subscript operators and iterator dereference
     and string/vector subscript operator all yields lvalue.
   - The built-in and iterator increment and decrement operator requires lvalue
     operand and the *prefix version* yields lvalue.

   For decltype, when we apply decltype with lvalue operand, the result is
   reference type.

** Order of Evaluation
   The only operators that guarantes order of evaluation is:
   - Logical AND
   - Logical OR
   - Conditional : ?
   - Comma ,

*** Order of Evaluation, Precedence and Associativity

    For the expression f() + g() * h() + j():
    - Precedence guarantees that the result of g() and h() are multiplied.
    - Associativity guarantees that the result of f() is added to the product of
      g() and h() and that result is added to the result of j().
    - No order of evaluation is guaranteed.
** Arithmetic Operator

   - All six arithmetic operators are left associative. 

   - The result they returned are *rvalue* object.

   - Operand will be converted to arithmetic type if possible.

   - Unary +, binary + and - can also be applied to pointer type.

   - true will be promote to 1 and false to 0.
     #+BEGIN_SRC C++
     bool b = true;
     bool b2 = -b; // b2 is also true.
     #+END_SRC
     In the above example, since the unary - converts its operand to arithmetic
     type, b, which has the value true, is converted to int with
     value 1. Applied the unary -, it becomes -1 which is then converted to bool
     type. Since it is a non-zero value, the result of b2 is true.

   - Overflow is undefined.

** Logical and Relational Operator
   - All left associative except logical NOT.

   - Logical operators convert operands to bool.

   - Relational operators convert operands to arithmetic type or pointer type.
     Therefore, when we say 
     #+BEGIN_SRC C++
     if(val == b)
     #+END_SRC
     
     It is equivalent to saying
      #+BEGIN_SRC C++
     if(val == 1)
     #+END_SRC
     Because the bool type b is converted to int type.
   

   - Results are rvalues.
** Increment and Decrement Operator
   - Prefix increment the object and yields the changed object as an lvalue
     result.
   - Postfix increment the object and yields a copy of the unchanged object as
     rvalue. 

** Conditional Operator
   cond ? expr1 : expr2
   - Low precedence
   - Right associative
   - Result is lvalue if both expressions are lvalues.
** Bitwise Operator
   - Right shift a signed integer is a machine dependent behavior.
** The sizeof Operator
   - The result is constexpr.
   - It does not evaluate its operand. sizeof(*p) is safe even if p is an
     invalid pointer.
   - As an exception, the array operand will not be converted to pointer type. 
   - Can use scope operator to get the size of member object.
** Type Conversion
*** Arithmetic Conversion
    
    Arithmetic conversions are defined to preserve precision.
*** Integral Promotion
    Integral promotions convert the small integral types to a larger integral
    type. The type bool, char, signed/unsigned char, signed/unsigned short are
    promoted to int if all possible values of that type fit in an
    int. Otherwise, it is converted to unsigned int.

    The larger char type such as wchar_t, wchar16_t and wchar32_t is promoted to
    the smallest type of int, unsigned int, long, unsigned long, long long and
    unsigned long long in which all possible values of that type can fit in.

*** Operand of Unsigned Type\
    Same size ==> Unsigned
    Same signedness ==> Larger

    Different signedness:
    if unsigned larger ==> unsigned
    else if equal ==> unsigned
    else (if signed larger) ==> fitness.

*** Array to Pointer Conversion
    All cases except:
    1. decltype
    2. sizeof operator
    3. address-of (&)operator: Pointer to an array.
    4. typeid
    5. initialization to a reference to an array.

*** Pointer Conversion
    1. 0 or nullptr can be converted to all pointer types
    2. a pointer to any non-const type can be converted to void*
    3. a pointer to any type can be converted to const void*

*** Conversion to bool
    Pointer and arithmetic types are converted to true is they are zero-valued
    and false otherwise.

*** Explicit Type Conversion: /cast_name<type>(expression);/
    1. static_cast: allow all kind of type conversion without complilation
       error.
    2. const_cast: remove const identifiable. Undefined if try to modify through
       it.
    3. reinterpret_cast

* Chapter 5: Statements
  
* Chapter 6: Functions
** Function Basics
   - A function definition contains a return type, a function name, a parameter
     list containing zero or more parameters and a funciton body.

   - We execute the function through the *call operator*, which is a pair of
     parentheses. It takes an expression that is a function or a pointer to a
     function.

   - Arguments are passed to the function and are *initializers* for the
     function's parameters. *The order of evaluation is not garuanteed.*

   - Argument passing is exactly like variable initialization.
** Local Objects
   - *Scope* of a name is the part of the program's text in which that name is
     visible.

   - *Lifetime* of a name is the timing during the program's execution that the
     object exists.

   - *Automatic Objects* are objects that exist only during the execution of a
     block. After the execution exits the block, automatic objects are
     destroyed and their values are undefined. Uninitialized automatic objects
     has undefined value.

   - *Local Static Object* is intialized before the first time the execution
     passes through the object's definition. Its lifetime is the entire
     execution of the program. It is like a global variable but private to the
     function that defines it.
** Argument Passing
*** Array argument
    - We cannot pass an array as a function's argument because we are not able
      to copy array. The compiler treats array as a pointer. When we pass the
      array to a function, we are actually passing a *pointer to the array's*
      *first element.*

    - The compiler has no way to know the extent of the passed array. We make
      use a marker to indicate the end (C-string) or include the size as another
      argument.

    - In the new C++11 standard. We can also use the library begin() and end()
      function.

    - We actually can make a function's parameter be the type of reference to an
      array. However, we must specify the exact size of the array because size
      if part of the array's type.
      #+BEGIN_SRC C++
      // OK: parameter is a reference to an array; the dimension is part of the type.
      void print(int (&arr)[10])
      {
          for(auto elem : arr)
              cout << elem << endl;
      }
      #+END_SRC

      In the above example, we can only pass "int [10]" to print.

** Initializer List

** The Return Statement
   - Returning is just like use the return value to initialize a variable at the
     call site.

   - Do not return local object as a reference.

** inline and constexpr Function
   - constexpr funcitons are implicitly inlined.

   - For a constexpr function, the return type and all parameters must be
     literal type and the function body must contain exactly one return
     statement.

   - inline and constexpr function may be defined everal times. To avoid
     unnecessary mass, those functions are usually defined in the header files.

** Function Overloading
   - Overloaded functions must differ in their parameter lists. Also, top-level
     const makes no difference.

*** const_cast and Overloading
    - const_cast is useful when using overloaded functionl
      #+BEGIN_SRC c++
      const string &isShorter(const string &s1, const string &s2)
      {
          return s1.size() <= s2.size() ? s1 : s2;
      }

      string &isShorter(string &s1, string &s2)
      {
          auto &r = isShorter(const_cast<const string&>(s1), const_cast<const string&>(s2));
	  return const_cast<string&>(r);i 
      }
      #+END_SRC
*** Overloading and Scope
    - Just as usual, a name declared in an inner scope hides all uses of that
      name declared in outer scope.
*** Function Matching
    - Matching steps
      1. Search for candicate function. A function is considered as a candidate
         if it has the same name and is visible in the current scope.
      2. Search viable functions in those candidates. A function is viable if it
         has the same number of parameters as there are arguments in the call,
         and the type of each argument must match --- or be convertible to ---
         the type of its corresponding parameter.
      3. Find the "best match".

    - "Best Match"?
      1. An exact match is the best. It happens when
	 - Argument and parameter have exactly the same type.

	 - An array or function to corresponding pointer conversion.

	 - Top-level const are added or discarded.

      2. If only Lower-level const is added.

      3. Integral promotion. When a smaller integral type is promoted to a
         larger type.
	 - Worth noting that small integral type are always promoted to int or
           larger type even if conversion to short is a seemingly closer
           conversion. 
	   #+BEGIN_SRC c++
	   void ff(int);
	   void ff(short); // Will be called only when the argument type is short.
	   ff('a');        // ff(int) is called: small integral type char is converted to int. 
#+END_SRC

      4. Arithmetic and pointer conversion.
	 - 0 and literal nullptr can be converted to pointer of any type.
	 - Any nonconst pointer type can be converted to void*.
	 - Pointers of any type can be converted to const void*.

      5. Class type conversion.

** Function Pointer
   - A function's type is determined by the type of its parameters and its
     return type. Name does not matter.

   - There is no conversion from one fp type to another fp type. However, we can
     always assign 0 or nullptr to indicate that this pf does not point to any
     function.

   - Automatic function-to-functor conversion applies only to parameters. Not
     return type, not decltype.

*** Function Pointer Parameters
    - In declaration: just write the function, compiler will convert it to
      function poitner; equivalent to writing the parameter as function pointer.
    - In argument passing: Just pass the function's name (automatic conversion
      to pointer).
    - Type alias. Note that decltype does not perform the function-2-pointer
      conversion.

*** Return a Function Poitner
    - Have to specify clearly that we want to return a function poitner. There
      is no automatic conversion.
    - Can also use type alias. But still take care when using decltype.

* Chapter 7: Classes


** Member function
 - Member funciton must be declared inside the class.
 - Member function may be defined outside or inside the class.
*** Introducing *this*
    - Member functions access the object on which they were called through an
      extra, implicit parameter named *this*. When we call the member funciton,
      *this* is initialized with the address of the obejct on which the function
      was invoked.

      #+BEGIN_SRC C++
      // pseudo-code illustration of how a call to a member funtion is translated.
      // by compiler.
      Sale_data::isbn(&total);
      #+END_SRC

    - *this* is an constant object. By default /this/ is a const pointer to a
      nonconst object.

    - By default initialization rule, since /this/ is a const pointer to a
      nonconst object, we are not able to bind /this/ to a const
      object. Therefore, we cannot call the member function if the object on
      which the function was invoked is a const object. So we need the "const"
      member function.

*** Introducing const member function
    - The purpose of the const is to modify the type of /this/ pointer. It makes
      the (const) pointer becomes low-level const. Therefore, we can bind it to
      a const object.

      #+BEGIN_SRC C++
      // pseudo-code illustration of how the compiler handles const modifier
      // of member function.
      Sales_data::isbn(const Sales_data* const this)
      #+END_SRC
      
      Therefore, we are not able to modify the content of the object in the body
      of a const member function （except the object has a /mutable/ data member).

    - Objects that are const, and pointers or references to const object may
      only call const member function.

*** More on Member Function
    - The class itself defines a scope.
    - The compiler processes classes in two step
      1. Data members declarations are processed first
      2. The member function bodies are then processed.
	 
    - Specify the return type to be a reference to return lvalue.

*** Constructor
**** Synthesized Default Constructor
     - The default constructor does the following two things for each data
       member: 
       1. If there is an in-class initializer, use it to initialize the member.
       2. Otherwise, default initialize the member.

     - The compiler writes the default construct for us only if we define *no*
       constructor. 

     - Sometimes the default constructor does the wrong thing:
       1. Built-in or compound type (such as arrays or pointers) that are
          defined inside a block have undefined value when they are default
          initialized. Therefore, classes that have data members of built-in or
          compound type should rely on the synthesized default constructor only
          if all such members have in-class initializer.

       2. Sometimes the compiler is not able to synthesize a default constructor
          for us. For example, class type data member that does not have a
          default constructor.

     - = default;
**** Constructor Initializer List

*** Copy, Assignment and Distruction
    - Like constructor, compiler will synthesize default operators for us. And
      also like constructor, those synthesized versions will sometimes fail. One
      example is when we want to dynamically allocate memory.

    - Some times it is handy to use vector or string to handle the situations
      when we want to allocate memory dynamically because the synthesized
      operators can operate correctly.
     
** Access Control
*** Friend
    - A class can allow another class or function to access it non-public
      members by making that class or function a friend.
    - Note that friend declaration only specifies access. It is not a
      "declaration" of a function. Therefore, we have to declare that function
      seperately. 

** Additional Class Feature
*** Class Member Revisited
**** Defining A Type Member
     - In addition to defining data and function members, a class can define its
       own local names for types. Type names defined by a class are subjected to
       the same access rule.
       #+BEGIN_SRC C++
         class Screen {
         public:
           typedef std::string::size_type pos;
         private:
           pos curser = 0;
           pos height = 0, weight = 0;
           std::string content;
         };
       #+END_SRC

       - We can also use the C++11 standard syntax of type alias.

       - Type member, unlike ordinary data member, must be defined before used.
**** Makeing Members inline
     - Functions *defined* inside the class are implicitly inlined.
**** Overloading Member Function
**** mutable Data Member
     - It happens sometimes that a class has a data member that we want to
       modify even inside a const member function.
     - A mutable data member is never const, even when it is a member of a const object.
**** Initializers for Data Member of Class Type
     - When we provide an in-class initializer, we must do so by either an = or
       curly braces.

*** Functions that Return *this
    - A const member function that return *this as a reference must have a
      return type that is a reference to const.

**** Overloading Based On const

*** Class Type
    - Forward Declaration: Incomplete Type
      We can create pointers or references to such types, and we can *declare*
      (but not define) functions that use such types as parameters and return
      type.

    - A class must be defined before we can write codes to create an object of
      that class.

    - Data member can be a class type only if the class is fully defined.

    - Undefined Behavior??
      https://stackoverflow.com/help/privileges/comment: On the Screen/Window_mgr example
      https://stackoverflow.com/questions/31345193/how-can-an-incomplete-type-be-used-as-a-template-parameter-to-vector-here
      Undefined Behavior?? 

      
*** Friendship Revisited
    - Friendship is not transitive. The class itself controls which classes or
      functions are its friend.

    - Make member functions of other classes a friend require careful
      structuring of the code.

    - Even if the function is defined after the friend specifier, it is still
      not considered declared by the compiler. We need to decalre that function
      seperately. Since such kind of function is automatically inlined, we can
      provide multiple definition of that function. However, each definition
      must be identical.

** Class Scope
   - Class defines its own scope. Outside the class scope, data and function
     members may be accessd only through an object, a reference or pointer using
     member access operator. We access type member from the class using the
     scope operator.

*** Scope and Members Defined Outside the Class
    - Since a class is a scope, we must specify the class name when we define
      functions outside the class. Outside the class, all the inner details of
      the class is hidden.

    - However, once we enter the scope of the class, the parameter list and the
      function body are in the class's scope. So we on longer need to specify
      the class name.

    - On the other hand, the return type of a function member is outside the
      scope because normally the return type appears before the name of the
      class is seen:
      #+BEGIN_SRC C++
      Window_mgr::ScreenIndex Window_mgr::addScreen(const Screen &s) 
      {
        // function body here.
      }
      #+END_SRC

*** Name Lookup and Class Scope
**** Normal Name Lookup
     1. First, look for a declaration of the name in the block in which the
        name was used. Only names declared before the use are considered.

     2. If the name isn't found, look in the enclosing scope(s).

     3. If no declaration is found, then the program is in error.

**** Name Lookup Inside Class Member Function
     - Class definitions are processd in two phases:
       1. First, the member declarations are compiled
       2. *Function bodies* are compiled only after the entire class has been
          seen. Note that even if function bodies are inside the class
          definition, the compiler will still process them after compiling all
          the member declarations.

***** Name Lookup for Class Member *Declaration*
      - 在 declaration 这个步骤中，names used for return types and for types in
        the parameter list must be seen before they are used. Here is an example
        to illustrate this point:
	#+BEGIN_SRC C++
          typedef double Money;
          string bal;
          class Account{
          public:
            Money balance() { return bal; }

          private:
            Money bal;
            // ...
          };
	#+END_SRC

	The type declaration of Money must be placed before the class.
	However, since the function body is process after all the declarations,
        the bal inside the member function balance refers to the private data
        member of class Account, but not the string.

      - Cannot redefine a type in the class scope.

***** Block-Scope Name Lookup inside Member Definition

** Constructor
*** Constructor Initializer List
    - It is worth noting that data members are initialized before the control
      enters the constructor's body. Therefore, in the following case, we are
      actually *assign* values to initialized members:
      #+BEGIN_SRC C++
        Sales_data::Sales_data(const string &s, unsigned cnt, double price)
        {
          bookNo = s;
          units_sold = cnt;
          revenue = price * cnt;
        }
      #+END_SRC

    - To actually initialize the data member, we have to use either in-class
      initializer or the constructor initialization list. Moreover, sometimes we
      have to do so.

    - If the data member is of type reference, const object or class type that
      does not have a default constructor, we have to actually "initialize" the
      data member.

    - Order of initialization is only determined by the order you define the
      data member inside the class. The order you write the initializer list
      does not affect this.
*** Default Argument and Constructor
    - A constructor that supplies defualt arguments for all its parameter also
      defines the default constructor.

    - There can only be one default constructor, otherwise there will be
      anbiguous function matching.

** Static Class Member
* Classes 精简版
  - *Interface* of class consists of the operations that users of the class can
    execute. 

  - *Implementation* includes data members and the bodies of member functions
    that consitute the interface.

** On "this" Pointer
   - Member functions access the object's data member through an implicitly
     parameter called "this".
     #+BEGIN_SRC c++
     // psudo-code illustration of how a call to a member function is translated
     Sales_data::isbn(&total);
     #+END_SRC

   - "this" is a const pointer to non-const object. Therefore, a const object
     cannot call ordinary member function since non-const pointer cannot points
     to const object.

   - the "const" specifier for member function
     The const specifier is used to modify "this" pointer. Const object can
     therefore call const member functions.

*** Overloading Member funciton based on const

** Data Member Initialization
   - Member are initialized before the constructor body is executed.

** Friendship
   - A class can allow annother class or function to access its private data
     member by granting that class or function as friend.

   - A friend declaration does not make that function visible to the rest of the
     program. We must declare it outside the class (even if we define the
     function as we are making the friend declaration).

   - Classes and *nonmember* function need not have been declared before they
     are used in a friend declaration. When a name first appears in a friend
     declaration, that name is assumed to be part of the surrounding scope.

** Class and Scope
   - Member function definitions are processed after the compiler processes all
     of the *declarations* in the class.
     
   - It only applied to names used *in* the member function bodies. Names used
     in declarations, including names used for return type and types in
     parameter list, must be seen before they are used.

   - Member type definition must be seen before used.

   - Name Look UP
     1. In current block

     2. In class

     3. In outer scope.

** Implicit Class Type Conversion
   - Every constructor that can be called with a single argument defines an
     "implicit conversion" to a class type.

   - Use "explicit" keyword to suppress the automatic conversion.

** Static Class Member
   - Objects do not contain data associated with static data member. Static
     functions are not bound to any object and therefore do not have a "this"
     pointer.

   - We can use an object, reference or pointer to access a static member.

   - They are not defined when we create objects of the class. They are not
     initialized by constructors. We must define and initialize them outside the
     class body.

   - const static member may be initialized in class body.

   - consexpr static member must be initialized inside class body.

   - Have to declare them outside to make them visible.

   - A class may contain static data member of its own type.
